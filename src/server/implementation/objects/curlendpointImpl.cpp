/* Autogenerated with kurento-module-creator */

#include <gst/gst.h>
#include "MediaPipeline.hpp"
#include <curlendpointImplFactory.hpp>
#include "curlendpointImpl.hpp"
#include <jsonrpc/JsonSerializer.hpp>
#include <KurentoException.hpp>
#include <commons/kmsrecordingprofile.h>
#include <SignalHandler.hpp>
#include <functional>

#define GST_CAT_DEFAULT kurento_curlendpoint_impl
GST_DEBUG_CATEGORY_STATIC (GST_CAT_DEFAULT);
#define GST_DEFAULT_NAME "KurentocurlendpointImpl"
#define USE_RECORDER 1

#if USE_RECORDER
#define FACTORY_NAME "lolrecorderendpoint"
#else
#define FACTORY_NAME "gstcurlendpoint"
#endif

namespace kurento
{
namespace module
{
namespace curlendpoint
{
typedef enum {
  KMS_URI_END_POINT_STATE_STOP,
  KMS_URI_END_POINT_STATE_START,
  KMS_URI_END_POINT_STATE_PAUSE
} KmsUriEndPointState;


curlendpointImpl::curlendpointImpl (const boost::property_tree::ptree &config,
                                    std::shared_ptr<MediaPipeline> mediaPipeline,
                                    const std::string &uri)  :
    UriEndpointImpl (config, std::dynamic_pointer_cast<MediaObjectImpl> (mediaPipeline),
                     FACTORY_NAME, uri)
{
#if USE_RECORDER  
    g_object_set (G_OBJECT (element), "profile", KMS_RECORDING_PROFILE_MP4_AUDIO_ONLY, NULL);
#else
    g_object_set (getGstreamerElement(), "audio", TRUE, NULL);
#endif    
}
curlendpointImpl::~curlendpointImpl() {
    gint state = -1;

  if (handlerOnStateChanged > 0) {
    unregister_signal_handler (element, handlerOnStateChanged);
  }

  g_object_get (getGstreamerElement(), "state", &state, NULL);

  if (state != 0 /* stop */) {
    GST_ERROR ("Recorder should be stopped when reaching this point");
  }
}
void curlendpointImpl::postConstructor()
{
  UriEndpointImpl::postConstructor();

  handlerOnStateChanged = register_signal_handler (G_OBJECT (element),
                          "state-changed",
                          std::function <void (GstElement *, gint) >
                          (std::bind (&curlendpointImpl::onStateChanged, this,
                                      std::placeholders::_2) ),
                          std::dynamic_pointer_cast<curlendpointImpl>
                          (shared_from_this() ) );
}

void
curlendpointImpl::onStateChanged (gint newState)
{
  switch (newState) {
  case KMS_URI_END_POINT_STATE_STOP: {
    GST_DEBUG_OBJECT (element, "State changed to Stopped");
    Stopped event (shared_from_this(), Stopped::getName() );
    signalStopped (event);
    break;
  }

  case KMS_URI_END_POINT_STATE_START: {
    GST_DEBUG_OBJECT (element, "State changed to Recording");
    Recording event (shared_from_this(), Recording::getName() );
    signalRecording (event);
    break;
  }

  case KMS_URI_END_POINT_STATE_PAUSE: {
    GST_DEBUG_OBJECT (element, "State changed to Paused");
    Paused event (shared_from_this(), Paused::getName() );
    signalPaused (event);
    break;
  }
  }

  std::unique_lock<std::mutex> lck (mtx);

  GST_TRACE_OBJECT (element, "State changed to %d", newState);

  state = newState;
  // cv.notify_one();
}

MediaObjectImpl *
curlendpointImplFactory::createObject (const boost::property_tree::ptree &config,
                                       std::shared_ptr<MediaPipeline> mediaPipeline,
                                       const std::string &uri) const
{
  return new curlendpointImpl (config, mediaPipeline, uri);
}

curlendpointImpl::StaticConstructor curlendpointImpl::staticConstructor;

curlendpointImpl::StaticConstructor::StaticConstructor()
{
  GST_DEBUG_CATEGORY_INIT (GST_CAT_DEFAULT, GST_DEFAULT_NAME, 0,
                           GST_DEFAULT_NAME);
}

} /* curlendpoint */
} /* module */
} /* kurento */
